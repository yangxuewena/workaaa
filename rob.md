# Practice
打家劫舍
## 问题
#### 
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额给一个非负整数 num，反复添加所有的数字，直到结果只有一个数字。
## 编程实现：
class Solution {  
public:  

    int rob(vector<int>& nums) {  
        if(nums.size()==0) return 0;  
        int i,dp[100000];  
        dp[0]=nums[0];  
        dp[1]=nums[0]>nums[1]?nums[0]:nums[1];  
        for(i=2;i<nums.size();i++){  
            dp[i]=max(dp[i-2]+nums[i],dp[i-1]);  
        }  
        return dp[nums.size()-1];  
    }  
};  
## 总结体会：
当强盗到房间n去抢劫时，看房间n-1有没有被抢劫。分为2种：当上一个相邻的房间n-1已经被抢劫时，则该房间不能被抢劫，此时抢劫得到的最大金额仍和房间n-1时相同；当上一个相邻的n-1房间没有被抢劫时，则本次抢劫金额为n-2的房间的最大金额加上本次房间的金额。